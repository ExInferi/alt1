import * as webpack from "webpack";
import * as path from "path";
import * as glob from "glob";
import * as fs from "fs";
import {baseConfig} from "./index";
import {Alt1WebpackConfiguration} from "./index";

//no types so import like this
var VueLoaderPlugin = require("vue-loader/lib/plugin");
var UglifyJSPlugin = require("uglifyjs-webpack-plugin");



/**
 * Returns a map of with direct subdirectory names as keys and paths of /index.tsx?/ as values for matching directories
 * @param pathstr
 */
export function findTopLevelModules(pathstr: string) {
	var allfiles = glob.sync(pathstr + "/*/index.*");
	var entries: { [name: string]: string } = {};
	for (var file of allfiles) {
		var rel = path.relative(pathstr, file);
		var m = path.basename(rel).match(/^index.tsx?/);
		if (!m) { continue; }
		var name = path.dirname(rel);
		if (!name.match(/^\w+$/)) { continue; }
		entries[name] = file;
	}
	return entries;
}

/**
 * Finds all files that match the regex filter and returns their full path mapped to their path relative to given path
 * @param pathstr
 * @param reg
 */
export function findEntries(pathstr: string, reg: RegExp) {
	var allfiles = glob.sync(pathstr + "/**/*");
	var entryarray = allfiles.filter(e => e.match(reg));
	var entries: { [name: string]: string } = {};
	for (var entry of entryarray) {
		var rel = path.relative(pathstr, entry);
		var filename = path.basename(entry);
		var m = filename.match(reg);
		if (!m) { continue; }
		var entryname = path.join(path.dirname(rel), m[1]).replace(/\\/g, "/");
		entries[entryname] = entry;
	}
	return entries;
}


export type OutMapper = (entryAbs: string) => webpack.Output;
export namespace OutMapper {
	export function otherRoot(srcroot: string, outroot: string): OutMapper {
		return function (entry) {
			var dir = path.dirname(entry);
			var rel = path.relative(srcroot, dir);
			var outdir = path.resolve(outroot, rel);
			return {
				path: outdir,
				publicPath: "/" + rel.replace(/\\/g, "/") + "/",
				filename: "[name].bundle.js"
			}
		}
	}
	export function subdir(dirname: string): OutMapper {
		return function (entry) {
			var dir = path.dirname(entry);
			var name = path.basename(entry);
			var outdir = path.resolve(dir, dirname, name);
			return {
				path: outdir,
				publicPath: "/",
				filename: "[name].bundle.js"
			}
		}
	}
}

export type ModuleShorthand = {
	entryfile?: string,
	mapper?: string,
	hook?: (conf: Alt1WebpackConfiguration) => Alt1WebpackConfiguration,
	libNameRoot?: string;//the name of the global variable to which the root exports are exported when sued without module bundler
	libName?: string;//the name of the package when exposed in a module bundler
};

export function runSubConfigs(mappers: { [id: string]: OutMapper }, pathstr: string, configroot: string) {
	var buildfiles = glob.sync(pathstr + "/**/*.build.@(ts|tsx|js|jsx)");
	var configs: Alt1WebpackConfiguration[] = [];
	for (var file of buildfiles) {
		var rawmod = require(file);
		var mod = (rawmod.default || rawmod) as ModuleShorthand;
		var rootdir = path.dirname(file);
		var buildname = path.basename(file);
		var buildmatch = buildname.match(/(\w+)\.build.(\w+)/);
		if (!buildmatch) { throw new Error("invalid build file name at: " + file); }
		var entry = buildmatch[1] + "." + buildmatch[2];
		if (mod.entryfile) { entry = mod.entryfile; }
		var config = baseConfig(configroot);
		var outmapper = mappers[mod.mapper];
		if (!outmapper) { throw new Error("module with no outmapper at: " + file); }
		var entryabs = path.resolve(rootdir, entry);
		config.output = outmapper(entryabs);
		config.entry = { [buildmatch[1]]: entryabs };
		if (mod.libName) {
			config.output.libraryTarget = "umd";
			config.output.library = {
				root: mod.libNameRoot || mod.libName,
				commonjs: mod.libName,
				amd: mod.libName
			} as any;//typedefs are wrong for this one
			config.output.globalObject = "(typeof self !== 'undefined' ? self : this)";
		}
		if (mod.hook) {
			config = mod.hook(config);
		}
		if (!config) {
			console.log("module " + file + " skipped by hook function");
			continue;
		}
		configs.push(config);
	}
	return configs;
}

export type NpmConfig = {
	name: string,
	main: string,
	runeappsType: string,
	runeappsLibNameRoot: string,
	runeappsLibEntry: string,
	runeappsTarget: "node" | "web" | null
};

/**
 * Finds all packages in given directory
 * @param pathstr
 */
export function findSubPackages(pathstr: string) {
	//var filenames = glob.sync(pathstr + "/**/package.json");
	//TODO rename these packages back to package.json and fix typescript/webpack require order to use index.ts instead of package.json#main
	var filenames = glob.sync(pathstr + "/**/package.json");
	var files: { config: NpmConfig, configFilePath: string }[] = [];
	for (var file of filenames) {
		var cnf = JSON.parse(fs.readFileSync(file, { encoding: "utf-8" })) as Partial<NpmConfig>
		if (!cnf.main) { continue; }
		if (!cnf.main) { throw "no main in " + file; }
		if (!cnf.name) { throw "no name in " + file; }
		if (!cnf.runeappsLibEntry) { throw "no runeappsLibEntry in " + file; }
		if (!cnf.runeappsLibNameRoot) { throw "no runeappsLibNameRoot in " + file; }
		if (!cnf.runeappsType) { throw "no runeappsType in " + file; }

		files.push({
			configFilePath: file,
			config: cnf as NpmConfig
		});
	}
	return files;
}
